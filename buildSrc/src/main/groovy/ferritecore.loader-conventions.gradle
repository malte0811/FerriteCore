plugins {
    id 'ferritecore.subproject-conventions'
}

String makeVersionSuffix() {
    if (System.getenv("GITHUB_ACTIONS") != null) {
        return "-GH"+System.getenv("GITHUB_RUN_NUMBER");
    } else {
        return "";
    }
}

archivesBaseName = "${mod_id}-${mod_version}${makeVersionSuffix()}-" + project.name.toLowerCase()

jar {
    manifest {
        attributes([
            'Specification-Title'     : mod_name,
            'Specification-Vendor'    : mod_author,
            'Implementation-Title'    : project.name,
            'Implementation-Vendor'   : mod_author,
            'Implementation-Timestamp': new Date().format("yyyy-MM-dd'T'HH:mm:ssZ"),
            'Timestampe'              : System.currentTimeMillis(),
            'Built-On-Java'           : "${System.getProperty('java.vm.version')} (${System.getProperty('java.vm.vendor')})",
            'Build-On-Minecraft'      : minecraft_version
        ])
    }
}

task signJar(description: "Sign jar") {
    doLast {
        if (project.hasProperty('keyStore')) {
            def path;
            if (project.name == "NeoForge") {
                path = jar.archivePath
            } else {
                path = remapJar.archivePath
            }
            logger.warn("Signing " + path + "\n")
            ant.signjar(jar: path,
                    alias: project.storeAlias,
                    keystore: project.keyStore,
                    storepass: project.storePass,
                    keypass: project.storePass
            )
        } else {
            logger.warn("No key store found, not signing the output jar\n")
        }
    }
}

build.finalizedBy signJar

compileJava.doFirst {
    // This is set by Mixin during annotation processing, but should not persist between subprobjects
    System.clearProperty("mixin.target.mapid")
}

// Technically only relevant on the Neo subproject, but does not hurt elsewhere
Spec<Task> notNeoTask = { Task it -> !it.name.startsWith("neo") } as Spec<Task>

tasks.withType(JavaCompile).matching(notNeoTask).configureEach {
    source(project(":Common").sourceSets.main.allSource)
}

tasks.named("processResources") {
    from project(":Common").sourceSets.main.output.resourcesDir
    dependsOn project(":Common").processResources
}

dependencies {
    implementation project(":Common")
}

// Loader-specific projects should not have any unit tests
compileTestJava.enabled = false
test.enabled = false

def version_replaces = [
    'version': mod_version,
    'mc_version': minecraft_version,
    'next_major_mc': next_major_mc,
    'neo_version': neo_version,
]

def generateModMetadata = tasks.register("generateModMetadata", ProcessResources) {
    inputs.properties version_replaces
    expand version_replaces
    from "src/main/templates"
    into "build/generated/sources/modMetadata"
}

sourceSets.main.resources.srcDir generateModMetadata

tasks.withType(Task) {
    if (it.name == "runServer") {
        it.standardInput = System.in
    }
}
